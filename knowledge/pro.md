
# 功能

✅ 已经实现的功能

    1. 基于Redis Zset的智能订单分配算法

    - 位置：RepairOrderServiceImpl.java:66-106
    - 根据管理员分数（负载）进行订单分配
    - 分配后自动更新管理员分数

    2. Redis缓存优化

    - 用户名缓存：userName:{userId}
    - 订单缓存：orderCache::{orderId}
    - 管理员数量缓存（注释掉的代码中）

    3. Spring Security + JWT 双重认证

    - JWT过滤器：JwtAuthenticationTokenFilter
    - 权限控制注解：@PreAuthorize

    4. 阿里云OSS文件上传

    - 位置：CommonController.java
    - 支持图片上传并返回URL

    5. 敏感信息脱敏

    - 位置：RepairOrderServiceImpl.java:166-172, 224-232
    - 普通用户看不到其他人的姓名、学号、电话、地址等

    6. MyBatis-Plus分页查询

    - 订单历史分页
    - 社区订单分页

    7. 用户反馈系统

    - FeedbackService 已实现

    8. 软删除 + 乐观锁

    - 所有表都有 is_deleted 和 version 字段

    9. 微信小程序登录

    - 通过OpenID进行用户识别

    10. AOP切面编程

    - AutoFillAspect - 自动填充创建时间、更新时间等

❌ 目前缺失的功能（可以作为亮点添加）

    1. 数据统计分析模块

    - 维修订单趋势分析
    - 管理员工作量统计
    - 订单完成率统计
    - 不同类型故障占比分析

    2. 智能推荐系统

    - 基于历史数据推荐最佳维修人员
    - 相似问题推荐

    3. WebSocket实时消息推送

    - 配置文件已预留但被注释：WebSocketConfiguration.java:9-16
    - 订单状态变更实时通知
    - 新订单分配通知

    4. Excel导出功能

    - POI依赖在pom.xml中被注释掉了：repair-server/pom.xml:136-144
    - 订单数据导出
    - 统计报表导出

    5. 多因子权重调度算法

    - 目前只按分数（负载）分配
    - 可以增加：技能匹配度、地理位置、历史评分等因子

    6. 订单评分/评价系统

    - Feedback表存在，但可以扩展为评分机制
    - 影响管理员的调度优先级

    7. 微信支付功能

    - application.yml中已预留配置但被注释：application.yml:95-106

建议

对于毕设申请，你可以：

    1. 保留已实现的核心功能作为基础
    2. 计划添加2-3个增强功能，比如：

    - 数据统计分析（容易实现，有展示效果）
    - WebSocket实时推送（只需取消注释并实现业务逻辑）
    - Excel导出（也比较容易）

    3. 重点包装"智能调度算法"：

    - 虽然现在只是简单的按分数分配
    - 可以在毕设中扩展为多因子权重算法
    - 这是核心创新点

这样既不会过度承诺，又能体现技术深度！





# 优化

确定评分因子

基于你现有的数据库字段，可以实现以下因子：

| 因子     | 权重 | 数据来源                        | 说明             |
| -------- | ---- | ------------------------------- | ---------------- |
| 负载均衡 | 30%  | admin.score（当前接单数）       | 接单越少得分越高 |
| 历史评分 | 35%  | feedback 表的平均评分           | 服务质量好的优先 |
| 完成速度 | 20%  | repair_order 表计算平均处理时长 | 处理快的优先     |
| 技能匹配 | 15%  | admin.group_name 与订单类型匹配 | 专业对口优先     |



方案一：基于现有字段的简化版（可以直接实现）

评分因子设计

// 综合得分 = 负载得分(40%) + 速度得分(30%) + 技能得分(30%)

    1. 负载均衡得分（40%）

// 接单越少，得分越高
负载得分 = (maxScore - adminScore) / maxScore * 100

    2. 处理速度得分（30%）

// 计算管理员历史订单的平均处理时长（从接单到完成的时间）
// 处理越快，得分越高
平均处理时长 = SUM(完成时间 - 接单时间) / 订单数
速度得分 = (1 - 当前管理员平均时长 / 最慢管理员平均时长) * 100

    3. 技能匹配得分（30%）

```Java
  // 根据订单故障描述关键词匹配管理员组别
  if (故障描述包含组别关键词) {
      技能得分 = 100
  } else {
      技能得分 = 50  // 基础分
  }
```









多因子权重算法设计思路

核心思想

把"选择哪个管理员"这个问题，转化为"给每个管理员打分，选分数最高的"

---

评分因子（基于你现有的数据）

    1. 负载均衡因子（40%权重）

目的： 让每个人接单数量相对均衡

计算方式：
负载得分 = (最大接单数 - 该管理员接单数) / 最大接单数 × 100

举例：

- 管理员A接了10单，管理员B接了5单，管理员C接了8单
- 最大接单数 = 10
- A的负载得分 = (10-10)/10 = 0分
- B的负载得分 = (10-5)/10 = 50分 ✅ 最高
- C的负载得分 = (10-8)/10 = 20分

---

    2. 处理速度因子（30%权重）

目的： 优先分给处理快的管理员

计算方式：

    1. 从数据库查每个管理员的历史订单
    2. 计算平均处理时长 = SUM(update_time - create_time) / 订单数
    3. 速度得分 = 处理越快得分越高

举例：

- 管理员A平均6小时处理完 → 80分 ✅
- 管理员B平均12小时处理完 → 60分
- 管理员C平均24小时处理完 → 30分

注意：

- 新管理员（没有历史订单）可以给个中等分，比如60分
- 这样既给新人机会，又不会完全偏向他们

---

    3. 技能匹配因子（30%权重）

目的： 专业问题分给专业的人

实现思路：

方案A（简单）： 关键词匹配

- 定义组别关键词库：
  硬件组: ["硬件", "蓝屏", "死机", "主板", "内存"]
  软件组: ["软件", "系统", "安装", "卡顿"]
  网络组: ["网络", "断网", "WiFi"]

- 检查故障描述是否包含管理员组别的关键词
- 匹配上 → 100分
- 没匹配上 → 50分（基础分）

方案B（复杂，可以后期优化）：

- 用机器学习训练一个分类器
- 根据历史数据预测哪个管理员最擅长这类问题

---

最终得分计算

综合得分 = 负载得分 × 40% + 速度得分 × 30% + 技能得分 × 30%

举例：

假设有个"系统安装"的订单，三个管理员：

| 管理员 | 组别   | 接单数 | 负载得分 | 平均时长 | 速度得分 | 技能匹配     | 综合得分                         |
| ------ | ------ | ------ | -------- | -------- | -------- | ------------ | -------------------------------- |
| A      | 硬件组 | 10     | 0        | 6h       | 80       | 50（不匹配） | 0×0.4 + 80×0.3 + 50×0.3 = 39     |
| B      | 软件组 | 5      | 50       | 12h      | 60       | 100（匹配✅） | 50×0.4 + 60×0.3 + 100×0.3 = 68 ✅ |
| C      | 网络组 | 8      | 20       | 24h      | 30       | 50（不匹配） | 20×0.4 + 30×0.3 + 50×0.3 = 32    |

结果： 选择管理员B（软件组），虽然他不是接单最少的，但技能对口+速度不错，综合得分最高！

---

为什么这个算法有亮点？

    1. 对比简单轮询

- ❌ 简单轮询：只看数量，不管能力
- ✅ 多因子：综合考虑能力、负载、专业性

    2. 实际应用价值

- 提高维修效率（快的人多干活）
- 提高维修质量（专业对口）
- 保证公平性（不会让某个人一直闲着）

    3. 可扩展性

可以在答辩时说：

- 现在是3个因子
- 未来可以加入：用户评分、地理位置、在线状态等
- 权重可以根据实际运行数据动态调整

    4. 技术深度

- 涉及算法设计（加权打分）
- 涉及数据分析（历史数据统计）
- 体现系统设计思维（不是简单的CRUD）

---

实现建议

第一步：数据库增强（可选）

如果想要更准确，可以给 repair_order 表加个字段：
ALTER TABLE repair_order ADD COLUMN `status` TINYINT DEFAULT 0
COMMENT '订单状态：0-待处理，1-处理中，2-已完成';

ALTER TABLE repair_order ADD COLUMN `finish_time` DATETIME
COMMENT '完成时间';

这样能更准确计算处理时长。

第二步：核心算法代码

写一个 SmartDispatchService 服务类，包含：

- calculateLoadScore() - 计算负载得分
- calculateSpeedScore() - 计算速度得分
- calculateSkillScore() - 计算技能得分
- smartDispatch() - 主调度方法

第三步：集成到现有代码

在 RepairOrderServiceImpl.submitAndAccepted() 中：
// 原来的代码：
Long acceptedUserId = zSetOperations取最小的那个;

// 改成：
Long acceptedUserId = smartDispatchService.smartDispatch(orderSubmitDTO.getFaultDescription());

---

答辩时怎么讲？

老师问： "你这个智能调度是怎么实现的？"

你答：

    1. "传统方法只考虑负载均衡，我设计了多因子权重算法"
    2. "综合考虑了三个维度：负载（40%）、速度（30%）、技能（30%）"
    3. "通过历史订单数据统计每个管理员的处理速度"
    4. "通过关键词匹配实现技能对口分配"
    5. "最后加权求和，选择得分最高的管理员"
    6. （如果有时间实现）"我还做了对比实验，智能调度比轮询效率提升了X%"

这样就显得很有技术含量了！🎯